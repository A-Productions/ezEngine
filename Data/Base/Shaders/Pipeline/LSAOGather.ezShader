[PLATFORMS]
ALL

[PERMUTATIONS]

DISTRIBUTED_SSAO_GATHERING

[RENDERSTATE]

DepthTest = false
DepthTestFunc = CompareFunc_Less
DepthWrite = false
CullMode = CullMode_None

[VERTEXSHADER]

#include <Shaders/Pipeline/FullscreenTriangleVertexShader.h>

[PIXELSHADER]

struct PS_IN
{
  float4 Position : SV_Position;
  float2 TexCoord0 : TEXCOORD0;
};

#include <Shaders/Common/GlobalConstants.h>
#include <Shaders/Common/Common.h>
#include "LSAOConstants.h"
#include "Utils.h"

Texture2D<float> DepthBuffer : register(t0);
SamplerState PointClampSampler;

StructuredBuffer<LineInstruction> LineInstructions : register(t1);
Buffer<uint> LineSweepOutputBuffer : register(t2);


// If not defined, all pixels gather all directions, otherwise the work will be distributed to a 3x3 grid.
#if DISTRIBUTED_SSAO_GATHERING
  #define NUM_SAMPLES_PER_PIXEL (NUM_SWEEP_DIRECTIONS_PER_FRAME / 9)
#else
  #define NUM_SAMPLES_PER_PIXEL NUM_SWEEP_DIRECTIONS_PER_FRAME
#endif


// If defined, the two closest samples instead of just one will be taken per direction.
#define TWO_SAMPLES_PER_DIR


//#define ASSERT(condition) if(!(condition)) { return float4(1, 0, 1, 0); }
#define ASSERT(condition)

float4 main(PS_IN input) : SV_Target
{
  float2 screenSize = ViewportSize.xy;
  float2 screenSizeSubOne = screenSize - float2(1.0f, 1.0f);
  float2 pixelPos = input.TexCoord0 * screenSize;
  float2 pixelPosInv = screenSizeSubOne - pixelPos;

  float occlusionAccum = 0.0f;
  float totalWeight = 0.0f;

  float pixelDepth = LinearizeZBufferDepth(DepthBuffer.SampleLevel(PointClampSampler, input.TexCoord0, 0.0f));

#if DISTRIBUTED_SSAO_GATHERING
  // Hardcoded 3x3 square.
  const uint startDirIdx = ((uint(pixelPos.x) % 3) + (uint(pixelPos.y) % 3) * 3) * NUM_SAMPLES_PER_PIXEL;
  [unroll] for (int i = 0; i < 4; ++i)
  {
    uint dirIndex = startDirIdx + i;
#else
  [unroll] for (uint dirIndex = 0; dirIndex < NUM_SAMPLES_PER_PIXEL; ++dirIndex)
  {
#endif
    float2 dir = Directions[dirIndex].Direction;

    uint lineInstructionIndex = Directions[dirIndex].LineInstructionOffset;

    // Compute which line is closest to this pixel. See ezScreenSpaceAmbientOcclusionPass::AddLinesForDirection
    // Note that we're using mostly float here instead of int as done by the CPU implementation.
    // This is quite a bit faster on GPU and doesn't suffer any accuracy issues since we're calculating with small integers (way below the 24bit limit).
    float2 lineOrigin;
    float lineSampleNumberFloat = 0.0f;
    {
      // Just like in ezScreenSpaceAmbientOcclusionPass::AddLinesForDirection we try to treat negative directions exactly like positive ones,
      // except for a flip in the lineOrigin.
      float2 absDir = abs(dir);

      float2 virtualPixelPos;
      virtualPixelPos.x = (absDir.x == dir.x) ? pixelPos.x : pixelPosInv.x;
      virtualPixelPos.y = (absDir.y == dir.y) ? pixelPos.y : pixelPosInv.y;

      // To avoid branch and code duplication:
      uint domAxis = (absDir.x > absDir.y) ? 0 : 1; // dominant axis
      uint secAxis = 1 - domAxis; // secondary axis

      float numStepsToLeftBorder = virtualPixelPos[domAxis] / absDir[domAxis];
      float secAtBorder = virtualPixelPos[secAxis] - numStepsToLeftBorder * absDir[secAxis];
      lineInstructionIndex += uint((screenSizeSubOne[secAxis] - secAtBorder) / LineToLinePixelOffset + 0.5f);
      lineOrigin = LineInstructions[lineInstructionIndex].FirstSamplePos;
      lineSampleNumberFloat = (pixelPos[domAxis] - lineOrigin[domAxis]) / dir[domAxis];
    }

    // Line instructions know the direction they belong to, use this to make sure that we're touching the right one.
    ASSERT((LineInstructions[lineInstructionIndex].LineDirIndex_totalWeight & 0xFFFF) == uint(dirIndex))

    // If everything went as planned, lineSampleNumber is never smaller than -1
    // Beeing smaller zero means that the start is "in front" of the pixel which can happen due to jittering.
    ASSERT((int)lineSampleNumberFloat >= -1);

    // Fetch two closest samples on this line.
    // Taking two instead of one cancels out most artifacts and further selection through depth comparision doesn't seem to be necesary anymore
#ifndef TWO_SAMPLES_PER_DIR
    lineSampleNumberFloat = round(lineSampleNumberFloat);
#endif

    uint lineSampleNumberFloor = (uint)lineSampleNumberFloat;
    uint sampleIndex = lineSampleNumberFloor + LineInstructions[lineInstructionIndex].LineSweepOutputBufferOffset;

    // Apply weighted with depth filter.
    float2 samplePos = lineOrigin + lineSampleNumberFloor * dir;
    //float toPixel = samplePos - pixelPos;
    float sampleDepth = LinearizeZBufferDepth(DepthBuffer.Load(int3(samplePos, 0)));
    if (abs(sampleDepth - pixelDepth) < DepthCutoffDistance)
    {
      uint rawSample = LineSweepOutputBuffer.Load(sampleIndex/2);

      uint sample = rawSample >> (16 * (sampleIndex % 2 == 0));
      sample &= 0xFFFF;

      occlusionAccum += f16tof32(sample);
      totalWeight += 1.0f;
    }

    // Second sample for better quality.
#ifdef TWO_SAMPLES_PER_DIR
    samplePos += dir; // = lineOrigin + lineSampleNumberCeil * dir;
    sampleDepth = LinearizeZBufferDepth(DepthBuffer.Load(int3(samplePos, 0)));
    if (abs(sampleDepth - pixelDepth) < DepthCutoffDistance)
    {
      ++sampleIndex;

      // Making this a dependent read comes with a suprisingly hefty perf penalty, so we just read again.
      //if(sampleIndex % 2 == 0 || rawSample == 0)
      uint rawSample = LineSweepOutputBuffer.Load(sampleIndex/2);

      uint sample = rawSample >> (16 * (sampleIndex % 2 == 0));
      sample &= 0xFFFF;

      occlusionAccum += f16tof32(sample);
      totalWeight += 1.0f;
    }
#endif
  }

  float output = 1.0f;
  if (totalWeight > 0.0f)
     output = saturate(1.0f - occlusionAccum / totalWeight);
  return output.xxxx;
}
