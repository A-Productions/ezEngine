[PLATFORMS]
ALL

[PERMUTATIONS]

[COMPUTESHADER]

#include <Shaders/Common/GlobalConstants.h>
#include "SSAOConstants.h"
#include "Utils.h"

Texture2D DepthBuffer : register(t0);

StructuredBuffer<LineInstruction> LineInstructions;
RWBuffer<float> LineSweepOutputBuffer;

// Minimum difference in occlusion to pop from the stack.
#define OCCLUSION_BIAS 0.00001f
// Minimum difference in orientation test to pop from the stack.
#define HULL_BIAS 0.00001f

// Computes occlusion from an occluder on a given position
// As suggested by the original paper we go with the simple "strategy 3" where we assume a fixed tangent plane.
float computeOcclusion(float occluderDotCamera, float invOccluderDist)
{
  const float tangentPlane = -0.85f; // Todo: Expose this parameter?
  const float falloffConstant = 2.0f; // Todo: Expose this parameter.

  // Our falloff function is "falloffConstant / (falloffConstant + dist)"
  // Todo: Experiment with other functions.
  float occluderFalloff = falloffConstant * invOccluderDist;
  occluderFalloff = occluderFalloff / (occluderFalloff + 1.0f);

  // Don't saturate! This will get negative values for non-occluders in the stack.
  // Note: Not saturating per line occlusion until the very end in the Gather pass seems to get rid of a lot of artifacts.
  // However, I can't make entirely sense of the underlying whys - as I understand the ambient occlusion equation the contribution from every direction should be >= 0
  // It might have something to do with the fact that we're not strictly integrating over the hemisphere around the normal.
  // (todo: get a better understanding of what's going on!)
  return tangentPlane + max(0.0f, occluderDotCamera - tangentPlane) * occluderFalloff;
}

void computeOccluderProps(float2 lastOccluderPos, float2 currentPos, float2 toCamera,
                          out float occluderDotCamera, out float occlusion)
{
  float2 occluderDir = lastOccluderPos - currentPos;
  float occluderInvDist = rsqrt(dot(occluderDir, occluderDir));
  occluderDotCamera = dot(occluderDir, toCamera) * occluderInvDist;
  occlusion = computeOcclusion(occluderDotCamera, occluderInvDist);
}


// Higher numbers make the algorithm more accurate but increase the GPR pressure
#define STACK_SIZE 16

// Stack for occlusion hull.
// Since we can't possibly provide a stack large enough, we overwrite existing values gradually.
// If we do so, we still pretend the stack grew beyond/below STACK_SIZE, i.e. we never clamp the top pointer but modulo it on every access.
// We effectively pretend that we actually have "currentTop" elements in the stack while we're actually reusing elements we already popped.
// This little trick gets around most artifacts involving stack size.
//
// We're using groupshared to take away register pressure, but we're not actually sharing any memory!
// Notices the organization to avoid bank conflict.
// The code below is trying to minimize access to the hullstack.
// todo: experiment with packing.
groupshared float2 hullStack[STACK_SIZE][SSAO_LINESWEEP_THREAD_GROUP];

[numthreads(SSAO_LINESWEEP_THREAD_GROUP, 1, 1)]
void main(uint DispatchID : SV_DispatchThreadID, uint ThreadID : SV_GroupThreadID)
{ 
  // Determine lineId for this thread. May be invalid due to group quantization.
  uint lineId = DispatchID;
  if(lineId >= TotalLineNumber)
    return;

  float2 screenSize = Viewport.zw;
  float2 screenSizeSubOne = screenSize - float2(1.0f, 1.0f);
  float2 inverseScreenSize = 1.0f / screenSize;

  // Unpack line instruction.
  LineInstruction instruction = LineInstructions[lineId];
  float2 samplePos = instruction.FirstSamplePos;
  uint bufferOffset = instruction.LineSweepOutputBufferOffset;
  uint bufferOffsetEnd = bufferOffset + (instruction.LineDirIndex_NumSamples >> 16);
  uint lineDirIndex = instruction.LineDirIndex_NumSamples & 0xFFFF;
  float2 directionSampleStep = Directions[lineDirIndex].Direction;
  float2 directionNormed = normalize(float2(directionSampleStep));

  // Init stack.
  hullStack[0][ThreadID] = samplePos;
  uint currentTop = 1;  // Index of the top element == size - 1

  // Keep last two occluders in register for fast access.
  // These two elements represent the very top of the stack!
  float2 occluderPos_last0 = samplePos;
  float2 occluderPos_last1 = samplePos;

  // Walk along this line.
  do
  {
    float depthBufferDepth = DepthBuffer.Load(int3(samplePos, 0)).r;
    float2 normalizedScreenCor = samplePos * inverseScreenSize * 2.0f - 1.0f;
    float3 viewPos = FastScreenCoordToViewSpace(normalizedScreenCor, depthBufferDepth);

    // All other calculations work in a 2D "line projected" space.
    float2 position = float2(dot(viewPos.xy, directionNormed), viewPos.z);
    float2 toCamera = -normalize(position);

    // Compute occlusions.
    float currentOccluderDotCamera, currentOcclusion;
    computeOccluderProps(occluderPos_last0, position, toCamera, currentOccluderDotCamera, currentOcclusion);
    float nextOccluderDotCamera, nextOcclusion;
    computeOccluderProps(occluderPos_last1, position, toCamera, nextOccluderDotCamera, nextOcclusion);

    // Don't pop more from the stack than it is large in a single iteration.
    // On the other hand we still keep the virtual stack size in currentTop, since declaring the stack empty leads to more artefacts than using the incorrect values.
    int stackIters = 0;
    const int maxIter = min(STACK_SIZE, currentTop);
    while(// Stack empty?
          stackIters < maxIter &&
          // Not convex?
          currentOccluderDotCamera < nextOccluderDotCamera - OCCLUSION_BIAS && 
          // Higher occlusion?
          currentOcclusion < nextOcclusion - HULL_BIAS)
    {
      // Pop stack.
      currentOccluderDotCamera = nextOccluderDotCamera;
      currentOcclusion = nextOcclusion;
      occluderPos_last0 = occluderPos_last1;
      occluderPos_last1 = hullStack[currentTop % STACK_SIZE][ThreadID];
      --currentTop;
      ++stackIters;

      // Peek top element.
      float nextOccluderDotCamera, nextOcclusion;
      computeOccluderProps(occluderPos_last1, position, toCamera, nextOccluderDotCamera, nextOcclusion);
    }

    // Push new value to the stack.
    // If we just popped an element from the stack, we don't need to put write back, since it is still there (we didn't delete it)
    ++currentTop;
    if(stackIters == maxIter)
    {
      hullStack[currentTop % STACK_SIZE][ThreadID] = occluderPos_last1;
    }
    occluderPos_last1 = occluderPos_last0;
    occluderPos_last0 = position;

    // Write current occlusion value out.
    LineSweepOutputBuffer[bufferOffset] = currentOcclusion;

    // Walk until we hit the screen border
    samplePos += directionSampleStep;
    ++bufferOffset;

  } while(bufferOffset < bufferOffsetEnd);
}
