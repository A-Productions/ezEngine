[PLATFORMS]
ALL

[PERMUTATIONS]

BLUR_DIRECTION

[RENDERSTATE]

DepthTest = false
DepthTestFunc = CompareFunc_Less
DepthWrite = false
CullMode = CullMode_None

[VERTEXSHADER]

#include <Shaders/Pipeline/FullscreenTriangleVertexShader.h>

[PIXELSHADER]

struct PS_IN
{
  float4 Position : SV_Position;
  float2 TexCoord0 : TEXCOORD0;
};

#include <Shaders/Common/GlobalConstants.h>
#include "SSAOConstants.h"
#include "Utils.h"

Texture2D DepthBuffer : register(t0);
SamplerState PointClampSampler;

StructuredBuffer<LineInstruction> LineInstructions : register(t1);
Buffer<float> LineSweepOutputBuffer : register(t2);


//#define ASSERT(condition) if(!(condition)) { return float4(1, 0, 1, 0); }
#define ASSERT(condition)

float4 main(PS_IN input) : SV_Target
{
  float2 screenSize = Viewport.zw;
  float2 screenSizeSubOne = screenSize - float2(1.0f, 1.0f);
  float2 pixelPos = input.TexCoord0 * screenSize;
  float2 pixelPosInv = screenSizeSubOne - pixelPos;

  float occlusionAccum = 0.0f;
  float numSamples = 0.0f;

  //float pixelDepth = LinearizeZBufferDepth(DepthBuffer.Sample(PointClampSampler, input.TexCoord0).r);

  for (int dirIndex = 0; dirIndex < NUM_SWEEP_DIRECTIONS_PER_FRAME; ++dirIndex)
  {
    float2 dir = Directions[dirIndex].Direction;

    uint lineInstructionIndex = Directions[dirIndex].LineInstructionOffset;
    int lineSampleNumber;

    // Compute which line is closest to this pixel. See ezScreenSpaceAmbientOcclusionPass::AddLinesForDirection
    // Note that we're using mostly float here instead of int as done by the CPU implementation.
    // This is quite a bit faster on GPU and doesn't suffer any accuracy issues since we're calculating with small integers (way below the 24bit limit).
    int2 lineOrigin;
    {  
      // Just like in ezScreenSpaceAmbientOcclusionPass::AddLinesForDirection we try to treat negative directions exactly like positive ones,
      // except for a flip in the lineOrigin.
      float2 absDir = abs(dir); // Using uint because DX11 warning says int divide is slower.

      float2 virtualPixelPos;
      virtualPixelPos.x = (absDir.x == dir.x) ? pixelPos.x : pixelPosInv.x;
      virtualPixelPos.y = (absDir.y == dir.y) ? pixelPos.y : pixelPosInv.y;

      if(absDir.x > absDir.y)
      {
        float numStepsToLeftBorder = virtualPixelPos.x / absDir.x;
        float yAtBorder = virtualPixelPos.y - numStepsToLeftBorder * absDir.y;
        lineInstructionIndex += uint((screenSizeSubOne.y - yAtBorder) / LineToLinePixelOffset);

        lineOrigin = LineInstructions[lineInstructionIndex].FirstSamplePos;
        lineSampleNumber = int((pixelPos.x - lineOrigin.x) / dir.x);
      }
      else
      {
        float numStepsToBottomBorder = virtualPixelPos.y / absDir.y;  // + half abs dir?
        float xAtBorder = virtualPixelPos.x - numStepsToBottomBorder * absDir.x;
        lineInstructionIndex += uint((screenSizeSubOne.x - xAtBorder) / LineToLinePixelOffset);

        lineOrigin = LineInstructions[lineInstructionIndex].FirstSamplePos;
        lineSampleNumber = int((pixelPos.y - lineOrigin.y) / dir.y);
      }
    }
    
    // Line instructions know the direction they belong to, use this to make sure that we're touching the right one.
    ASSERT((LineInstructions[lineInstructionIndex].LineDirIndex_NumSamples & 0xFFFF) == uint(dirIndex))

    // If everything went as planned, lineSampleNumber is never smaller than -1
    // Beeing smaller zero means that the start is "in front" of the pixel which can happen due to jittering. 
    ASSERT(lineSampleNumber >= -1);

    // Check depth at this sample.
    /*int2 samplePos = lineOrigin + lineSampleNumber * dir;
    float sampleDepth = LinearizeZBufferDepth(DepthBuffer.Load(int3(samplePos, 0)).r);
    const float maxSampleDepthDifference = 1.1f;
    if(abs(sampleDepth - pixelDepth) > maxSampleDepthDifference)
      continue;*/

    // Fetch sweep sample.
    lineSampleNumber += LineInstructions[lineInstructionIndex].LineSweepOutputBufferOffset;
    occlusionAccum += LineSweepOutputBuffer.Load(lineSampleNumber).r;
    numSamples += 1.0f;

    // Debug line sample index.
    //return float4((lineSampleNumber* 0.01f), 0.0f, 0.0f, 1.0f);

    // Debug lineInstructionIndex
    //return float4(frac(lineInstructionIndex * 0.005f), 0.0f, 0.0f, 1.0f);
  }

  float output = 1.0f - occlusionAccum / numSamples;
  return float4(output, output, output, output);
}
