[PLATFORMS]
ALL

[PERMUTATIONS]

DISTRIBUTED_SSAO_GATHERING

[RENDERSTATE]

DepthTest = false
DepthTestFunc = CompareFunc_Less
DepthWrite = false
CullMode = CullMode_None

[VERTEXSHADER]

#include <Shaders/Pipeline/FullscreenTriangleVertexShader.h>

[PIXELSHADER]

struct PS_IN
{
  float4 Position : SV_Position;
  float2 TexCoord0 : TEXCOORD0;
};

#include <Shaders/Common/GlobalConstants.h>
#include <Shaders/Common/Common.h>
#include "SSAOConstants.h"
#include "Utils.h"

Texture2D DepthBuffer : register(t0);
SamplerState PointClampSampler;

StructuredBuffer<LineInstruction> LineInstructions : register(t1);
Buffer<float> LineSweepOutputBuffer : register(t2);


// If not defined, all pixels gather all directions, otherwise the work will be distributed to a 3x3 grid.
#if DISTRIBUTED_SSAO_GATHERING
  #define NUM_SAMPLES_PER_PIXEL (NUM_SWEEP_DIRECTIONS_PER_FRAME / 9)
#else
  #define NUM_SAMPLES_PER_PIXEL NUM_SWEEP_DIRECTIONS_PER_FRAME
#endif

//#define ASSERT(condition) if(!(condition)) { return float4(1, 0, 1, 0); }
#define ASSERT(condition)

float4 main(PS_IN input) : SV_Target
{
  float2 screenSize = Viewport.zw;
  float2 screenSizeSubOne = screenSize - float2(1.0f, 1.0f);
  float2 pixelPos = input.TexCoord0 * screenSize;
  float2 pixelPosInv = screenSizeSubOne - pixelPos;

  float occlusionAccum = 0.0f;
  float totalWeight = 0.0f;

  float pixelDepth = LinearizeZBufferDepth(DepthBuffer.Sample(PointClampSampler, input.TexCoord0).r);

#if DISTRIBUTED_SSAO_GATHERING
  // Hardcoded 3x3 square.
  const uint startDirIdx = ((uint(pixelPos.x) % 3) + (uint(pixelPos.y) % 3) * 3) * NUM_SAMPLES_PER_PIXEL;
  [unroll] for (int i = 0; i < NUM_SAMPLES_PER_PIXEL; ++i)
  {
    uint dirIndex = startDirIdx + i;
#else
  [unroll] for (uint dirIndex = 0; dirIndex < NUM_SAMPLES_PER_PIXEL; ++dirIndex)
  {
#endif
    float2 dir = Directions[dirIndex].Direction;

    uint lineInstructionIndex = Directions[dirIndex].LineInstructionOffset;

    // Compute which line is closest to this pixel. See ezScreenSpaceAmbientOcclusionPass::AddLinesForDirection
    // Note that we're using mostly float here instead of int as done by the CPU implementation.
    // This is quite a bit faster on GPU and doesn't suffer any accuracy issues since we're calculating with small integers (way below the 24bit limit).
    float2 lineOrigin;
    float lineSampleNumberFloat = 0.0f;
    {  
      // Just like in ezScreenSpaceAmbientOcclusionPass::AddLinesForDirection we try to treat negative directions exactly like positive ones,
      // except for a flip in the lineOrigin.
      float2 absDir = abs(dir); // Using uint because DX11 warning says int divide is slower.

      float2 virtualPixelPos;
      virtualPixelPos.x = (absDir.x == dir.x) ? pixelPos.x : pixelPosInv.x;
      virtualPixelPos.y = (absDir.y == dir.y) ? pixelPos.y : pixelPosInv.y;

      // To avoid branch and code duplication:
      uint domAxis = (absDir.x > absDir.y) ? 0 : 1; // dominant axis
      uint secAxis = 1 - domAxis; // secondary axis

      float numStepsToLeftBorder = virtualPixelPos[domAxis] / absDir[domAxis];
      float secAtBorder = virtualPixelPos[secAxis] - numStepsToLeftBorder * absDir[secAxis];
      lineInstructionIndex += uint((screenSizeSubOne[secAxis] - secAtBorder) / LineToLinePixelOffset + 0.5f);
      lineOrigin = LineInstructions[lineInstructionIndex].FirstSamplePos;
      lineSampleNumberFloat = (pixelPos[domAxis] - lineOrigin[domAxis]) / dir[domAxis];
    }
    
    // Line instructions know the direction they belong to, use this to make sure that we're touching the right one.
    ASSERT((LineInstructions[lineInstructionIndex].LineDirIndex_totalWeight & 0xFFFF) == uint(dirIndex))

    // If everything went as planned, lineSampleNumber is never smaller than -1
    // Beeing smaller zero means that the start is "in front" of the pixel which can happen due to jittering. 
    ASSERT((int)lineSampleNumberFloat >= -1);

    // Fetch two closest samples on this line.
    // Taking two instead of one cancels out most artifacts and further selection through depth comparision doesn't seem to be necesary anymore
    uint lineSampleNumberFloor = (uint)lineSampleNumberFloat;
    uint lineSampleNumberCeil = lineSampleNumberFloor + 1; //(int)ceil(lineSampleNumberFloat);
    uint lineBufferOffset = LineInstructions[lineInstructionIndex].LineSweepOutputBufferOffset;

    // Apply directly
    //occlusionAccum += LineSweepOutputBuffer.Load(lineSampleNumberFloor).r;
    //occlusionAccum += LineSweepOutputBuffer.Load(lineSampleNumberCeil).r;
    //totalWeight += 2.0f;

    // Apply weighted with depth filter.
    //const float distFactor = 0.05f;
    float2 samplePos = lineOrigin + lineSampleNumberFloor * dir;
    //float toPixel = samplePos - pixelPos;
    float sampleDepth = LinearizeZBufferDepth(DepthBuffer.Load(int3(samplePos, 0)).r);
    float weight = exp(-square(sampleDepth - pixelDepth) * DepthCutoffFactor);// - dot(toPixel, toPixel) * distFactor);
    occlusionAccum += LineSweepOutputBuffer.Load(lineSampleNumberFloor + lineBufferOffset).r * weight;
    totalWeight += weight;

    samplePos += dir; // = lineOrigin + lineSampleNumberCeil * dir;
    sampleDepth = LinearizeZBufferDepth(DepthBuffer.Load(int3(samplePos, 0)).r);
    //toPixel = samplePos - pixelPos;
    weight = exp(-square(sampleDepth - pixelDepth) * DepthCutoffFactor); // - dot(toPixel, toPixel) * distFactor);
    occlusionAccum += LineSweepOutputBuffer.Load(lineSampleNumberCeil + lineBufferOffset).r * weight;
    totalWeight += weight;

    // Debug line sample index.
    //return float4((lineSampleNumber* 0.01f), 0.0f, 0.0f, 1.0f);

    // Debug lineInstructionIndex
    //return float4(frac(lineInstructionIndex * 0.005f), 0.0f, 0.0f, 1.0f);
  }

  float output = 1.0f;
  if (totalWeight > 0.0f)
     output = 1.0f - saturate(occlusionAccum / totalWeight);
  return output.xxxx;
}
