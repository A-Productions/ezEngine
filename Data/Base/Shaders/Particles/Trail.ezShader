[PLATFORMS]
ALL

[PERMUTATIONS]

[RENDERSTATE]

BlendingEnabled0 = true
DestBlend0 = Blend_One
SourceBlend0 = Blend_InvSrcAlpha

DepthTest = true
DepthWrite = false
CullMode = CullMode_None

[VERTEXSHADER]

#define USE_TEXCOORD0
#define USE_COLOR

#include <Shaders/Common/GlobalConstants.h>
#include <Shaders/Materials/MaterialInterpolator.h>
#include <Shaders/Particles/TrailShaderData.h>

#if EZ_ENABLED(PLATFORM_DX11)

VS_OUT main(uint VertexID : SV_VertexID)
{
  float2 texCoords[6] =
  {
    float2(0.0, 0.0),
    float2(1.0, 0.0),
    float2(1.0, 1.0),
    float2(0.0, 0.0),
    float2(1.0, 1.0),
    float2(0.0, 1.0),
  };

  uint particleIndex = VertexID / (6 * TRAIL_SEGMENTS);
  uint trailPointIndex = (VertexID - (particleIndex * 6 * TRAIL_SEGMENTS)) / 6;
  uint vertexSubIndex = VertexID % 6;

  ezTrailParticleData particle = particleData[particleIndex];

  VS_OUT ret;

  if (trailPointIndex + 2 >= particle.NumPoints)
  {
    ret.Position = float4(0, 0, 0, 0);
    ret.TexCoords = float2(0, 0);
    ret.Color = float4(0, 1, 1, 0);
  }
  else
  {
    float factor = texCoords[vertexSubIndex].x;

    // doing this and then accessing the data will silently not work on nVidia cards and just result in the drawcall being ignored
    //ezTrailParticlePointsData trail = particlePointsData[particleIndex];

    // UV step is currently calculated over the maximum number of segments, instead of the active number of segments
    // this means at start the texture is cut off, instead of stretching over the full UV space
    // doing it differently would be very complicated though
    float uvStep = 1.0 / (TRAIL_POINTS - 3);
    float uvCoord1 = uvStep * trailPointIndex; // coordinate at the left side of the segment
    float uvCoord2 = uvCoord1 + uvStep; // coordinate at the right side of the segment
    float uvSubtract = uvStep * particle.SnapshotFraction; // to adjust the UV coordinates while the first position glides along, to not have jumps when a new segment is added

    float3 position1 = particlePointsData[particleIndex].Positions[trailPointIndex].xyz;
    float3 position2 = particlePointsData[particleIndex].Positions[trailPointIndex + 1].xyz;
    float3 position3 = particlePointsData[particleIndex].Positions[trailPointIndex + 2].xyz;

    // position for THIS vertex
    float3 thisPosition = lerp(position1, position2, factor);

    float3 direction1 = position1 - position2;
    float3 direction2 = position2 - position3;

    float3 segmentDirection = -lerp(direction1, direction2, factor);

    float3 dirRight = mul(ObjectToWorldMatrix, float4(segmentDirection, 0)).xyz;
    float3 dirUp = normalize(cross(dirRight, CameraDirForwards)) * particle.Size;

    float4 offsetRight = float4(dirRight * texCoords[vertexSubIndex].x, 0);
    float4 offsetUp = float4(dirUp * (texCoords[vertexSubIndex].y - 0.5), 0);

    float4 position = mul(ObjectToWorldMatrix, float4(thisPosition, 1)) + offsetUp;

    ret.Position = mul(WorldToScreenMatrix, position);
    ret.TexCoords = texCoords[vertexSubIndex];
    ret.TexCoords.x = lerp(uvCoord1, uvCoord2, factor);
    ret.Color = RGBA8ToFloat4(particle.Color);

    // do NOT adjust the UV of the very first vertex, that is the one moves all the time and is always at UV.x == 0
    // however, DO adjust the coordinate of the LAST vertex, since that is not moving and needs to "fade away" (out of the UV space, ie > 1)
    if (ret.TexCoords.x > 0.01)
      ret.TexCoords.x -= uvSubtract;

    // manually clamp the texCoords
    // this could be set as a sampler state, but it would not work with sub-ranges (once we support texture atlases)
    ret.TexCoords.x = min(1.0, ret.TexCoords.x);
  }

  return ret;
}

#endif


[PIXELSHADER]

#define USE_TEXCOORD0
#define USE_COLOR

#include <Shaders/Materials/MaterialInterpolator.h>

#if EZ_ENABLED(PLATFORM_DX11)

Texture2D ParticleTexture;
SamplerState ParticleTexture_AutoSampler;

float4 main(PS_IN Input) : SV_Target
{
  float4 texCol = ParticleTexture.Sample(ParticleTexture_AutoSampler, Input.TexCoords.xy);
  //return texCol;
  return float4(texCol.rgb * Input.Color.rgb * Input.Color.a, texCol.a);
  //return float4(Input.Color.rgb, 0.0);// 1.0 - Input.Color.a);
  //return float4(0, 1, 0, 0);
}

#endif

