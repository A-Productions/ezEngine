[PLATFORMS]
ALL

[PERMUTATIONS]

BLEND_MODE
RENDER_PASS
SHADING_MODE
TWO_SIDED
FLIP_WINDING = FALSE
MSAA
CAMERA_MODE
SHADING_QUALITY
FORWARD_PASS_WRITE_DEPTH

[MATERIALPARAMETER]

int KrautTreeMode; // 0 == regular mesh, 1 == frond, 2 == leaf, 3 == static impostor, 4 == billboard impostor


[RENDERSTATE]

#include <Shaders/Materials/MaterialState.h>

[VERTEXSHADER]

#define VSE_CONSTANTS INT1(KrautTreeMode);

#define USE_COLOR
#define USE_NORMAL
#define USE_TANGENT
#define USE_TEXCOORD0
#define USE_TEXCOORD1
#define CUSTOM_INTERPOLATOR float3 LeafNormal : TEXCOORD2;

#if RENDER_PASS == RENDER_PASS_EDITOR
  #define USE_DEBUG_INTERPOLATOR
#endif

#include <Shaders/Materials/DefaultMaterialCB.h>
#include <Shaders/Materials/MaterialVertexShader.h>
#include "TreeShaderData.h"

VS_OUT main(VS_IN Input)
{
  VS_OUT result = FillVertexData(Input);

  ezPerInstanceData data = GetInstanceData();
  float4x4 objectToWorld = TransformToMatrix(data.ObjectToWorld);
  float4 worldPosition = mul(objectToWorld, float4(Input.Position.xyz, 1));

  result.LeafNormal = float3(0, 0, 0);

  [branch]
  if (KrautTreeMode == 4) // Billboard Impostor
  {
    worldPosition.xyz += GetCameraDirRight() * result.TexCoords.z;
    result.TexCoords.z = 1.0;
    result.Normal = -GetCameraDirForwards();
    result.Normal.z = 0;
    result.Normal = normalize(result.Normal);
    result.Tangent = GetCameraDirRight();
    result.BiTangent = float3(0, 0, 1);
  }

  [branch]
  if (KrautTreeMode == 2) // Leaf
  {
    result.LeafNormal = worldPosition.xyz - mul(objectToWorld, float4(LeafCenter, 1));

    float2 span = result.TexCoords.xy * 2.0 - 1.0;
    float size = result.TexCoords.z;

    worldPosition.xyz += span.x * GetCameraDirRight() * size;
    worldPosition.xyz += span.y * GetCameraDirUp() * size;

    result.TexCoords.z = 1.0;
    result.Normal = -GetCameraDirForwards();
    result.Normal.z = 0;
    result.Normal = normalize(result.Normal);
    result.Tangent = GetCameraDirRight();
    result.BiTangent = float3(0, 0, 1);

    [branch]
    if (LeafShadowOffset > 0.0)
    {
      worldPosition.xyz += GetCameraDirForwards() * size;
    }
  }

  result.WorldPosition = worldPosition;

  float4 cameraPosition = mul(GetWorldToCameraMatrix(), worldPosition);
  float4 screenPosition = mul(GetCameraToScreenMatrix(), cameraPosition);
  result.Position = screenPosition;

  return result;
}

[GEOMETRYSHADER]

#define VSE_CONSTANTS INT1(KrautTreeMode);

#define USE_COLOR
#define USE_NORMAL
#define USE_TANGENT
#define USE_TEXCOORD0
#define USE_TEXCOORD1
#define CUSTOM_INTERPOLATOR float3 LeafNormal : TEXCOORD2;

#include <Shaders/Materials/MaterialStereoGeometryShader.h>

[PIXELSHADER]

#define VSE_CONSTANTS INT1(KrautTreeMode);

#define USE_COLOR
#define USE_NORMAL
#define USE_TANGENT
#define USE_TEXCOORD0
#define USE_TEXCOORD1
#define USE_SIMPLE_MATERIAL_MODEL
#define USE_MATERIAL_OCCLUSION
#define USE_TWO_SIDED_LIGHTING
#define USE_FOG
#define CUSTOM_INTERPOLATOR float3 LeafNormal : TEXCOORD2;

#if RENDER_PASS == RENDER_PASS_EDITOR
  #define USE_DEBUG_INTERPOLATOR
#endif

#include <Shaders/Materials/DefaultMaterialCB.h>
#include <Shaders/Materials/MaterialPixelShader.h>

Texture2D BaseTexture;
SamplerState BaseTexture_AutoSampler;

Texture2D NormalTexture;
SamplerState NormalTexture_AutoSampler;

//Texture2D RoughnessTexture;
//SamplerState RoughnessTexture_AutoSampler;

float2 GetTexCoord()
{
  float2 tc = G.Input.TexCoords.xy;
  // unfortunately we have to DIVIDE in the pixel shader with the original value
  // if we use the inverse of TexCoords.z and interpolate that in the vertex-shader
  // the result has a slightly different value in the pixel shader,
  // resulting in drastically reduced quality
  tc = tc / G.Input.TexCoords.z;
  tc.y = 1.0 - tc.y;

  return tc;
}

float3 GetBaseColor()
{
  float3 variationColor = BaseColor.rgb;
  float variationStrength = BaseColor.a;
  float vertexStrength = G.Input.Color.a;

  //float3 baseColor = BaseColor.rgb * GetInstanceData().Color.rgb;
  float3 texColor = BaseTexture.Sample(BaseTexture_AutoSampler, GetTexCoord()).rgb;

  float3 finalColor = lerp(texColor, variationColor, vertexStrength * variationStrength);
  finalColor *= G.Input.Color.rgb;

  return finalColor;
}

float3 GetNormal()
{
  float3 normalTS = DecodeNormalTexture(NormalTexture.Sample(NormalTexture_AutoSampler, GetTexCoord()));

  // TODO: validate / preprocess: since we flip sampling the textures, the normal is also pointing in the other direction
  normalTS.y = -normalTS.y;

  float3 wsNormal = TangentToWorldSpace(normalTS);

  [branch]
  if (KrautTreeMode == 2) // Leaf
  {
    wsNormal += normalize(G.Input.LeafNormal);
  }

  return normalize(wsNormal);
}

float GetMetallic()
{
  return 0;
}

float GetReflectance()
{
  return 0.5f;
}

float GetRoughness()
{
  return 1.0f;
}

float GetOpacity()
{
  float opacity = BaseTexture.Sample(BaseTexture_AutoSampler, GetTexCoord()).a;

  #if BLEND_MODE == BLEND_MODE_MASKED
     return opacity - 0.1;
   #else
    return opacity;
  #endif
}


float GetOcclusion()
{
  return G.Input.TexCoords.w;
}