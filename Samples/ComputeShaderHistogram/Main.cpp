#include "Main.h"
#include <Foundation/IO/FileSystem/FileSystem.h>
#include <Foundation/IO/FileSystem/DataDirTypeFolder.h>
#include <Foundation/Logging/Log.h>
#include <Foundation/Logging/ConsoleWriter.h>
#include <Foundation/Logging/VisualStudioWriter.h>
#include <Core/Input/InputManager.h>
#include <System/Window/Window.h>
#include <RendererFoundation/Descriptors/Descriptors.h>
#include <RendererFoundation/Device/Device.h>
#include <RendererDX11/Device/DeviceDX11.h>
#include <Foundation/Configuration/Startup.h>
#include <RendererFoundation/Device/SwapChain.h>
#include <RendererCore/ShaderCompiler/ShaderManager.h>
#include <Core/ResourceManager/ResourceManager.h>
#include <RendererCore/Textures/TextureResource.h>
#include <RendererCore/Meshes/MeshBufferResource.h>
#include <CoreUtils/Geometry/GeomUtils.h>
#include <Foundation/Time/Clock.h>
#include <RendererFoundation/Resources/RenderTargetSetup.h>
#include <RendererFoundation/Context/Context.h>
#include <RendererCore/RenderContext/RenderContext.h>
#include <CoreUtils/Graphics/Camera.h>

static ezUInt32 g_uiWindowWidth = 1920;
static ezUInt32 g_uiWindowHeight = 1080;
static ezUInt32 g_uiComputeThreadGroupSize = 32;

class ezShaderExplorerWindow : public ezWindow
{
public:

  ezShaderExplorerWindow()
    : ezWindow()
  {
    m_bCloseRequested = false;
  }

  virtual void OnClickCloseMessage() override
  {
    m_bCloseRequested = true;
  }

  bool m_bCloseRequested;
};

ezComputeShaderHistogramApp::ezComputeShaderHistogramApp()
  : ezApplication()
  , m_pWindow(nullptr)
  , m_pDevice(nullptr)
{
}

ezComputeShaderHistogramApp::~ezComputeShaderHistogramApp()
{
}

ezApplication::ApplicationExecution ezComputeShaderHistogramApp::Run()
{
    m_pWindow->ProcessWindowMessages();

    if (m_pWindow->m_bCloseRequested || ezInputManager::GetInputActionState("Main", "CloseApp") == ezKeyState::Pressed)
      return ApplicationExecution::Quit;
    // update all input state
    ezInputManager::Update(ezClock::GetGlobalClock()->GetTimeDiff());

    // make sure time goes on
    ezClock::GetGlobalClock()->Update();

    m_stuffChanged = false;
    m_directoryWatcher->EnumerateChanges(ezMakeDelegate(&ezComputeShaderHistogramApp::OnFileChanged, this));
    if (m_stuffChanged)
    {
      ezResourceManager::ReloadAllResources(false);
    }

    // do the rendering
    {
      // Before starting to render in a frame call this function
      m_pDevice->BeginFrame();

      // The ezGALContext class is the main interaction point for draw / compute operations
      ezGALContext& GALContext = *m_pDevice->GetPrimaryContext();
      ezRenderContext& renderContext = *ezRenderContext::GetDefaultInstance();

      // Constant buffer update
      {
        auto& globalConstants = renderContext.WriteGlobalConstants();
        ezMemoryUtils::ZeroFill(&globalConstants);

        globalConstants.Viewport = ezVec4(0, 0, (float)g_uiWindowWidth, (float)g_uiWindowHeight);
        // Wrap around to prevent floating point issues. Wrap around is dividable by all whole numbers up to 11.
        globalConstants.GlobalTime = (float)ezMath::Mod(ezClock::GetGlobalClock()->GetAccumulatedTime().GetSeconds(), 20790.0);
        globalConstants.WorldTime = globalConstants.GlobalTime;
      }

      ezRectFloat viewport(0.0f, 0.0f, (float)g_uiWindowWidth, (float)g_uiWindowHeight);

      // Draw background.
      {
        ezGALRenderTagetSetup RTS;
        RTS.SetRenderTarget(0, m_hScreenRTV);
        renderContext.SetViewportAndRenderTargetSetup(viewport, RTS);

        renderContext.BindShader(m_hScreenShader);
        renderContext.BindMeshBuffer(ezGALBufferHandle(), ezGALBufferHandle(), nullptr, ezGALPrimitiveTopology::Triangles, 1); // Vertices are generated by shader.
        renderContext.DrawMeshBuffer();
      }

      // Copy screentexture contents to backbuffer.
      // (Is drawing better? Don't care, this is a one liner and needs no shader!)
      {
        GALContext.CopyTexture(m_pDevice->GetBackBufferTextureFromSwapChain(m_pDevice->GetPrimarySwapChain()), m_hScreenTexture);
      }

      // Switch to backbuffer (so that the screen texture is no longer bound)
      {
        ezGALRenderTagetSetup RTS;
        RTS.SetRenderTarget(0, m_hBackbufferRTV);
        renderContext.SetViewportAndRenderTargetSetup(viewport, RTS);
      }

      // Compute histogram.
      {
        // Reset first.
        GALContext.ClearUnorderedAccessView(m_hHistogramUAV, ezVec4U32(0, 0, 0, 0));

        renderContext.BindShader(m_hHistogramComputeShader);
        renderContext.BindTexture(ezGALShaderStage::ComputeShader, "ScreenTexture", m_hScreenSRV);
        renderContext.BindRWTexture("HistogramOutput", m_hHistogramUAV);
        renderContext.Dispatch(g_uiWindowWidth / g_uiComputeThreadGroupSize + (g_uiWindowWidth % g_uiComputeThreadGroupSize != 0 ? 1 : 0),
                               g_uiWindowHeight / g_uiComputeThreadGroupSize + (g_uiWindowHeight % g_uiComputeThreadGroupSize != 0 ? 1 : 0));

        // Unbind UAV since it is used as SRV in next step. TODO: This should be handled automatically.
        renderContext.BindRWTexture("HistogramOutput", ezGALUnorderedAccessViewHandle());
        renderContext.ApplyContextStates();
      }

      // Draw histogram.
      {
        renderContext.BindShader(m_hHistogramDisplayShader);
        renderContext.BindMeshBuffer(m_hHistogramQuadMeshBuffer);
        renderContext.BindTexture(ezGALShaderStage::PixelShader, "HistogramTexture", m_hHistogramSRV);
        renderContext.DrawMeshBuffer();

        // Unbind SRV since it is used as UAV in the next frame. TODO: This should be handled automatically.
        renderContext.BindTexture(ezGALShaderStage::PixelShader, "HistogramTexture", ezGALResourceViewHandle());
        renderContext.ApplyContextStates();
      }

      m_pDevice->Present(m_pDevice->GetPrimarySwapChain());

      m_pDevice->EndFrame();
      ezRenderContext::GetDefaultInstance()->ResetContextState();
    }

    // needs to be called once per frame
    ezResourceManager::PerFrameUpdate();

    // tell the task system to finish its work for this frame
    // this has to be done at the very end, so that the task system will only use up the time that is left in this frame for
    // uploading GPU data etc.
    ezTaskSystem::FinishFrameTasks();

    return ezApplication::Continue;
}

void ezComputeShaderHistogramApp::AfterCoreStartup()
{
  m_directoryWatcher = EZ_DEFAULT_NEW(ezDirectoryWatcher);

  ezStringBuilder sBaseDir = BUILDSYSTEM_OUTPUT_FOLDER;
  sBaseDir.AppendPath("../../Data/Base/");

  ezStringBuilder sProjectDir = BUILDSYSTEM_OUTPUT_FOLDER;
  sProjectDir.AppendPath("../../Data/Samples/ComputeShaderHistogram");

  EZ_VERIFY(m_directoryWatcher->OpenDirectory(sProjectDir, ezDirectoryWatcher::Watch::Writes | ezDirectoryWatcher::Watch::Subdirectories).Succeeded(), "Failed to watch project directory");

  // setup the 'asset management system'
  {
    // which redirection table to search
    ezDataDirectory::FolderType::s_sRedirectionFile = "AssetCache/LookupTable.ezAsset";
    // which platform assets to use
    ezDataDirectory::FolderType::s_sRedirectionPrefix = "AssetCache/PC/";
  }

  ezFileSystem::RegisterDataDirectoryFactory(ezDataDirectory::FolderType::Factory);

  ezFileSystem::AddDataDirectory("", "", ":", ezFileSystem::AllowWrites);
  ezFileSystem::AddDataDirectory(ezOSFile::GetApplicationDirectory(), "AppBin", "bin", ezFileSystem::AllowWrites); // writing to the binary directory
  ezFileSystem::AddDataDirectory(ezOSFile::GetApplicationDirectory(), "ShaderCache", "shadercache", ezFileSystem::AllowWrites); // for shader files
  ezFileSystem::AddDataDirectory(ezOSFile::GetUserDataFolder("ezEngine Project/ComputeShaderHistogram"), "AppData", "appdata", ezFileSystem::AllowWrites); // app user data

  ezFileSystem::AddDataDirectory(sBaseDir.GetData(), "Base", "base");
  ezFileSystem::AddDataDirectory(sProjectDir.GetData(), "Project", "project", ezFileSystem::AllowWrites);

  ezGlobalLog::AddLogWriter(ezLogWriter::Console::LogMessageHandler);
  ezGlobalLog::AddLogWriter(ezLogWriter::VisualStudio::LogMessageHandler);

  ezPlugin::LoadPlugin("ezInspectorPlugin");

  EZ_VERIFY(ezPlugin::LoadPlugin("ezShaderCompilerHLSL").Succeeded(), "Compiler Plugin not found");

  // Register Input
  {
    ezInputActionConfig cfg;

    cfg = ezInputManager::GetInputActionConfig("Main", "CloseApp");
    cfg.m_sInputSlotTrigger[0] = ezInputSlot_KeyEscape;
    ezInputManager::SetInputActionConfig("Main", "CloseApp", cfg, true);
  }

  // Create a window for rendering
  {
    ezWindowCreationDesc WindowCreationDesc;
    WindowCreationDesc.m_ClientAreaSize.width = g_uiWindowWidth;
    WindowCreationDesc.m_ClientAreaSize.height = g_uiWindowHeight;
    m_pWindow = EZ_DEFAULT_NEW(ezShaderExplorerWindow);
    m_pWindow->Initialize(WindowCreationDesc);
  }

  // Create a device
  {
    ezGALDeviceCreationDescription DeviceInit;
    DeviceInit.m_bCreatePrimarySwapChain = true;
    DeviceInit.m_bDebugDevice = true;
    DeviceInit.m_PrimarySwapChainDescription.m_pWindow = m_pWindow;
    DeviceInit.m_PrimarySwapChainDescription.m_SampleCount = ezGALMSAASampleCount::None;
    DeviceInit.m_PrimarySwapChainDescription.m_bAllowScreenshots = true;
    DeviceInit.m_PrimarySwapChainDescription.m_bVerticalSynchronization = false;//true;

    m_pDevice = EZ_DEFAULT_NEW(ezGALDeviceDX11, DeviceInit);
    EZ_VERIFY(m_pDevice->Init() == EZ_SUCCESS, "Device init failed!");

    ezGALDevice::SetDefaultDevice(m_pDevice);
  }

  // now that we have a window and device, tell the engine to initialize the rendering infrastructure
  ezStartup::StartupEngine();

  // Get the primary swapchain (this one will always be created by device init except if the user instructs no swap chain creation explicitly)
  {
    ezGALSwapChainHandle hPrimarySwapChain = m_pDevice->GetPrimarySwapChain();
    const ezGALSwapChain* pPrimarySwapChain = m_pDevice->GetSwapChain(hPrimarySwapChain);

    m_hBackbufferRTV = m_pDevice->GetDefaultRenderTargetView(pPrimarySwapChain->GetBackBufferTexture());
  }

  // Create textures and texture view for screen content (can't use backbuffer as shader resource view)
  {
    ezGALTextureCreationDescription texDesc;
    texDesc.m_uiWidth = g_uiWindowWidth;
    texDesc.m_uiHeight = g_uiWindowHeight;
    texDesc.m_Format = ezGALResourceFormat::RGBAUByteNormalized; //ezGALResourceFormat::RGBAUByteNormalizedsRGB;
    texDesc.m_bCreateRenderTarget = true;
    texDesc.m_bAllowShaderResourceView = true;

    m_hScreenTexture = m_pDevice->CreateTexture(texDesc);
    m_hScreenRTV = m_pDevice->GetDefaultRenderTargetView(m_hScreenTexture);
    m_hScreenSRV = m_pDevice->GetDefaultResourceView(m_hScreenTexture);
  }

  // Create texture for histogram data.
  {
    ezGALTextureCreationDescription texDesc;
    texDesc.m_uiWidth = 256;
    texDesc.m_uiHeight = 3; // R, G, B
    texDesc.m_uiMipLevelCount = 1;
    texDesc.m_Format = ezGALResourceFormat::RUInt;
    texDesc.m_bCreateRenderTarget = false;
    texDesc.m_bAllowShaderResourceView = true;
    texDesc.m_bAllowUAV = true;
    texDesc.m_ResourceAccess.m_bImmutable = false;

    m_hHistogramTexture = m_pDevice->CreateTexture(texDesc);
    m_hHistogramSRV = m_pDevice->GetDefaultResourceView(m_hHistogramTexture);

    ezGALUnorderedAccessViewCreationDescription uavDesc;
    uavDesc.m_hTexture = m_hHistogramTexture;
    m_hHistogramUAV = m_pDevice->CreateUnorderedAccessView(uavDesc);
  }

  // Setup Shaders and Materials
  {
    ezShaderManager::Configure("DX11_SM50", true);
    m_hScreenShader = ezResourceManager::LoadResource<ezShaderResource>("Shaders/screen.ezShader");
    m_hHistogramComputeShader = ezResourceManager::LoadResource<ezShaderResource>("Shaders/histogramcompute.ezShader");
    m_hHistogramDisplayShader = ezResourceManager::LoadResource<ezShaderResource>("Shaders/histogramdisplay.ezShader");
  }

  // Geometry.
  CreateHistogramQuad();

  // UAV for histogram
}

void ezComputeShaderHistogramApp::BeforeCoreShutdown()
{
  m_directoryWatcher->CloseDirectory();

  ezRenderContext::GetDefaultInstance()->BindMaterial(ezMaterialResourceHandle());

  m_hScreenShader.Invalidate();
  m_hHistogramDisplayShader.Invalidate();
  m_hHistogramComputeShader.Invalidate();
  m_hHistogramQuadMeshBuffer.Invalidate();

  m_hScreenRTV.Invalidate();
  m_hScreenSRV.Invalidate();
  m_pDevice->DestroyTexture(m_hScreenTexture);
  m_hScreenTexture.Invalidate();

  m_pDevice->DestroyUnorderedAccessView(m_hHistogramUAV);
  m_hHistogramUAV.Invalidate();
  m_hHistogramSRV.Invalidate();
  m_pDevice->DestroyTexture(m_hHistogramTexture);
  m_hHistogramTexture.Invalidate();

  // tell the engine that we are about to destroy window and graphics device,
  // and that it therefore needs to cleanup anything that depends on that
  ezStartup::ShutdownEngine();

  // now we can destroy the graphics device
  m_pDevice->Shutdown();

  EZ_DEFAULT_DELETE(m_pDevice);

  // finally destroy the window
  m_pWindow->Destroy();
  EZ_DEFAULT_DELETE(m_pWindow);

  m_directoryWatcher.Reset();
}

void ezComputeShaderHistogramApp::CreateHistogramQuad()
{
  m_hHistogramQuadMeshBuffer = ezResourceManager::GetExistingResource<ezMeshBufferResource>("{4BEFA142-FEDB-42D0-84DC-58223ADD8C62}");

  if (!m_hHistogramQuadMeshBuffer.IsValid())
  {
    ezVec2 pixToScreen(1.0f / g_uiWindowWidth * 0.5f, 1.0f / g_uiWindowHeight * 0.5f);
    const float borderOffsetPix = 80.0f;
    const float sizeScreen = 0.8f;

    ezGeometry geom;
    ezMat4 transform(ezMat3::IdentityMatrix(), ezVec3( 1.0f - pixToScreen.x * borderOffsetPix - sizeScreen/2,
                                                      -1.0f + pixToScreen.y * borderOffsetPix + sizeScreen/2, 0.0f));
    geom.AddRectXY(ezVec2(sizeScreen, sizeScreen), ezColor::Black, transform);

    ezMeshBufferResourceDescriptor desc;
    desc.AddStream(ezGALVertexAttributeSemantic::Position, ezGALResourceFormat::XYZFloat);
    desc.AddStream(ezGALVertexAttributeSemantic::TexCoord0, ezGALResourceFormat::XYFloat);
    desc.AllocateStreams(geom.GetVertices().GetCount(), ezGALPrimitiveTopology::Triangles, geom.GetPolygons().GetCount() * 2);

    for (ezUInt32 v = 0; v < geom.GetVertices().GetCount(); ++v)
    {
      desc.SetVertexData<ezVec3>(0, v, geom.GetVertices()[v].m_vPosition);
    }
    // (Making use of knowledge of vertex order)
    desc.SetVertexData<ezVec2>(1, 0, ezVec2(0.0f, 0.0f));
    desc.SetVertexData<ezVec2>(1, 1, ezVec2(1.0f, 0.0f));
    desc.SetVertexData<ezVec2>(1, 2, ezVec2(1.0f, 1.0f));
    desc.SetVertexData<ezVec2>(1, 3, ezVec2(0.0f, 1.0f));

    ezUInt32 t = 0;
    for (ezUInt32 p = 0; p < geom.GetPolygons().GetCount(); ++p)
    {
      for (ezUInt32 v = 0; v < geom.GetPolygons()[p].m_Vertices.GetCount() - 2; ++v)
      {
        desc.SetTriangleIndices(t, geom.GetPolygons()[p].m_Vertices[0], geom.GetPolygons()[p].m_Vertices[v + 1], geom.GetPolygons()[p].m_Vertices[v + 2]);

        ++t;
      }
    }

    m_hHistogramQuadMeshBuffer = ezResourceManager::CreateResource<ezMeshBufferResource>("{4BEFA142-FEDB-42D0-84DC-58223ADD8C62}", desc);
  }
}

void ezComputeShaderHistogramApp::OnFileChanged(const char* filename, ezDirectoryWatcherAction action)
{
  if (action == ezDirectoryWatcherAction::Modified)
  {
    ezLog::Info("The file %s was modified", filename);
    m_stuffChanged = true;
  }
}

EZ_CONSOLEAPP_ENTRY_POINT(ezComputeShaderHistogramApp);
